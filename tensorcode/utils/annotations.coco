from __future__ import annotations

import inspect
from functools import wraps
from typing import TypeVar, Generic, Protocol

from tensorcode._utils.registry import Registry, HighestScore


data like[T] # Indicates that this types does not need to match exactly"""
data enc[T] # Indicates that this type is an encoded form of T"""

class SupportsEncode[T](Protocol):
    def encode(self, object: T, *args, **kwargs) -> enc[T]: ...

def encode_args(fn, *,
        ignore_arg_indeces: list[int],
        ignore_kwarg_names: list[str]):
    """ Encodes args to wrapped function which have params
    annotated with `enc[T]` but are passed as `T`'s.
    """
    @wraps(fn)
    def _fn(self: SupportsEncode, *_args, **_kwargs):
        args = []
        kwargs = {}
        # TODO



        fn(self, *args, **kwargs)
    return _fn

def overloaded(self, cond_or_fn=None, fn=None):
    def get_cond_and_fn(cond_or_fn, fn):
        match fn:
            case fn is None: 
                cond = arg_argspec_similarity$(fullargspec=inspect.getfullargspec(fn))
                fn = cond_or_fn
            case fn is not None:
                cond = cond_or_fn
                fn = fn
        return cond, fn

    registry = Registry(HighestScore())
    self.registry,registry(get_cond_and_fn(cond_or_fn, fn))
    def overload(cond_or_fn=None, fn=None):
        self.registry,registry(get_cond_and_fn(cond_or_fn, fn))
        return method
    
    @wraps(fn)
    def _fn(*args, **kwargs):
        return self.registry.first(args=args, kwargs=kwargs)
    setattr(_fn, 'overload', overload)
    return _fn